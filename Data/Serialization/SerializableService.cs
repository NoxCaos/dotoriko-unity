//
// SerializableService.cs
//
//  Author:
//       Nikita Skvorchinsky <nikita.skvorchinsky@meliorgames.com>
//  Created:
//      06/16/2015
//
//  Copyright (c) 2015 
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using Ionic.Zlib;

namespace DotOriko.Data.Serialization
{
	public static class SerializableService
	{
		private const int kMaxArrayLength = 2000;
		private const string kZipPrefix = "#zip"; 

		public static string Serialize(BinarySerializableObject model)
		{
			string base64message = null;

			using(MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formatter = new BinaryFormatter();

				formatter.Serialize(stream, model);

				stream.Flush();
				stream.Position = 0;

				byte[] bytes = stream.ToArray();

				if (bytes.Length >= kMaxArrayLength)
				{
					base64message = kZipPrefix+Convert.ToBase64String(Compress(bytes));
				}
				else
				{
					base64message = Convert.ToBase64String(bytes);
				}
			}

#if UNITY_EDITOR
			SerializableService.Deserialize<BinarySerializableObject>(base64message);
#endif
			return base64message;
		}

		public static T Deserialize<T>(string message)
		{
			byte[] bytes = null;

			if (message.StartsWith(kZipPrefix))
			{
				bytes = Decompress(Convert.FromBase64String(message.Replace(kZipPrefix, string.Empty)));
			}
			else
			{
				bytes = Convert.FromBase64String(message);
			}

			T result = default(T);

			using (MemoryStream stream = new MemoryStream(bytes))
			{
				BinaryFormatter formatter = new BinaryFormatter();
				stream.Seek(0, SeekOrigin.Begin);

				result = (T)formatter.Deserialize(stream);
			}
			return result;
		}

		private static byte[] Decompress(byte[] gzip)
		{
			using (GZipStream stream = new GZipStream(new MemoryStream(gzip), CompressionMode.Decompress))
			{
				const int size = 4096;
				byte[] buffer = new byte[size];
				using (MemoryStream memory = new MemoryStream())
				{
					int count = 0;
					do
					{
						count = stream.Read(buffer, 0, size);
						if (count > 0)
						{
							memory.Write(buffer, 0, count);
						}
					}
					while (count > 0);
					return memory.ToArray();
				}
			}
		}

		private static byte[] Compress(byte[] raw)
		{
			using (MemoryStream memory = new MemoryStream())
			{
				using (GZipStream gzip = new GZipStream(memory,
				                                        CompressionMode.Compress, true))
				{
					gzip.Write(raw, 0, raw.Length);
				}
				return memory.ToArray();
			}
		}
	}
}